# ZooKeeper

## 什么是ZooKeeper  

* 分布式应用程序  
分布式应用程序并发的在网络上运行，通过协调不同节点的进行以快速有效的方式完成特定任务。  
优点：高可用、可扩展、透明  
缺点：竞争条件、死锁、数据不一致  

* 分布式协同技术  
分布式协同技术主要是用来解决分布式环境中多个进程之间的同步问题，让他们有序的去访问某种临界资源，防止造成脏数据的后果。  
分布式锁机制保证分布式系统中多个进程能够有序的访问资源-将资源锁死给某一进程  

* ZooKeeper  
	* ZK就是这样一种基于分布式锁机制的分布式协同技术
	* ZooKeeper 的设计目标是将那些复杂且容易出错的分布式一致性服务封装起来，构成一个高效可靠的原语集，并以一系列简单易用的接口提供给用户使用。
	* 主要用来解决分布式应用中经常遇到的数据一致性的问题：
		* 统一命名服务
		* 状态同步服务
		* 集群管理 
		* 分布式应用配置项管理  
	* ZK作为分布式服务框架，能够提供基于类似于文件系统的目录节点树方式的数据存储，数据监控，数据同步等功能，从而达到监控和管理集群的目的。  
	
## ZK的起源  
下面这段内容摘自《从 Paxos 到 ZooKeeper 》第四章第一节的某段内容：  
Zookeeper 最早起源于雅虎研究院的一个研究小组。  
在当时，研究人员发现，在雅虎内部很多大型系统基本都需要依赖一个类似的系统来进行分布式协调，但是这些系统往往都存在分布式单点问题。

所以，雅虎的开发人员就试图开发一个通用的无单点问题的分布式协调框架，以便让开发人员将精力集中在处理业务逻辑上。

关于“ZooKeeper”这个项目的名字，其实也有一段趣闻。在立项初期，考虑到之前内部很多项目都是使用动物的名字来命名的（例如著名的Pig项目)，雅虎的工程师希望给这个项目也取一个动物的名字。

时任研究院的首席科学家 Raghu Ramakrishnan 开玩笑地说：“在这样下去，我们这儿就变成动物园了！”

此话一出，大家纷纷表示就叫动物园管理员吧，因为各个以动物命名的分布式组件放在一起，雅虎的整个分布式系统看上去就像一个大型的动物园了。

而 Zookeeper 正好要用来进行分布式环境的协调，于是，Zookeeper 的名字也就由此诞生了。


## 为什么使用ZK  
* 维护一个分布式应用非常困难，主要原因就是因为局部故障，一个消息通过网络在两个节点之间传递时，网络如果发生故障，发送方并不知道接受方是否接收到这个消息
* 分布式应用程序需要一个主控、协调器或者控制器来管理分布的子进程
* 目前大部分应用开发私有的协调程序，缺乏一个通用性的协调程序
* ZK提供了通用的分布式锁服务，用以协调分布式应用，比如：  
	* Hadoop借助ZK实现了保证只有一个活跃的NameNode、ResouceManager的存在，存储配置信息等。
	* Hbase使用ZK的事件处理确保集群中只有一个活跃的HMaster并察觉HRegionServer联机和宕机，存储访问控制列表等。

## ZK的功能
* 命名服务：按名称来识别集群中的节点
* 配置管理：加入节点的系统配置信息的最大化
* 集群管理：实时连接、离开 集群中的节点和节点状态
* 领导选举：选择节点作为协调目标的领导者
* 锁定和同步服务：修改数据时锁定数据，此机制可帮助您在连接其他分布式应用程序（HBase）时进行自动故障恢复
* 高度可靠的数据注册表：数据即使在一个或者多个节点关闭时的可用性


## ZK优缺点  
* 顺序一致性：从同一客户端发起的事务请求，最终将会严格地按照顺序被应用到 ZooKeeper 中去。

* 原子性：所有事务请求的处理结果在整个集群中所有机器上的应用情况是一致的，也就是说，要么整个集群中所有的机器都成功应用了某一个事务，要么都没有应用。

* 单一系统映像：无论客户端连到哪一个 ZooKeeper 服务器上，其看到的服务端数据模型都是一致的。

* 可靠性：一旦一次更改请求被应用，更改的结果就会被持久化，直到被下一次更改覆盖。

## ZK的架构

* 角色
ZK集群中，服务器有两种角色，Leader和Learner，Learner角色又分为Observer和Follower：  
	* Leader领导者：负责进行投票的发起和决议，更新系统状态
	* Learner学习者：  
		* Follower跟随者：用于接收客户端请求并向客户端返回结果，在选主过程中参与投票
		* Observer观察者：接收客户端连接，将写请求转发给Leader，但Observer不参加投票过程，只同步Leader状态，Observer的目的是为了扩展系统，提高读取速度
	* Client客户端：请求发起方

<img src="https://upload-images.jianshu.io/upload_images/22827736-adacfbf8b0a46185.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" width="100%">


## ZK工作机制
从设计模式角度来看，ZK是一个基于观察者模式设计的分布式管理框架，他负责管理大家都关心的数据，然后接收观察者的注册，一旦数据发生变化，ZK就通知已经在ZK注册的观察者做出相应的反应  
> ZK = 文件系统 + 通知机制  


* 集群中只要有半数以上的节点存活，ZK集群就能正常运行  
* 全局数据一致性，每个Server保存一份相同的数据，Client无论连接到哪个Server，数据都是一致的
* 更新请求顺序进行，来自同一个Client的更新请求按发送顺序依次进行
* 数据更新原子性，一次数据更新要么成功要么失败
* 实时性，在一定的范围内，Client能读取到最新的数据


## ZK的选举机制  
* ZK默认的算法是FastLeaderElection，采用投票数大于半数则胜出的逻辑。      
* 与选举相关的概念  
	* 服务器ID  
		比如有三台服务器，编号为1,2,3  
		编号越大在选择算法中的权重越大  
	* 选举状态  
		* LOOKING，竞选
		* Following，随从状态，同步Leader状态，参与投票
		* Observing，观察状态，同步Leader状态，不参与投票
		* Leading，领导者状态  
	* 数据ID
		* 服务器中存放的最新数据vesion
		* 值越大说明数据越新，在选举算法中数据越大，权重越大
	* 逻辑时钟
		* 也叫投票次数，同一轮投票过程中的逻辑时钟值是相同的。
		* 每投完一次票这个数就会增加，然后与接收到的其他服务器返回的投票信息中的数值相比，根据不同的值做出不同的判断。
* 集群选举
	* 全新集群选举  
		假设目前有 5 台服务器，每台服务器均没有数据，它们的编号分别是1,2,3,4,5,按编号依次启动，它们的选择举过程如下：
		* 服务器 1 启动，给自己投票，然后发投票信息，由于其它机器还没有启动所以它收不到反馈信息，服务器 1 的状态一直属于 Looking。
		* 服务器 2 启动，给自己投票，同时与之前启动的服务器 1 交换结果，由于服务器 2 的编号大所以服务器 2 胜出，但此时投票数没有大于半数，所以两个服务器的状态依然是 LOOKING。
		* 服务器 3 启动，给自己投票，同时与之前启动的服务器 1,2 交换信息，由于服务器 3 的编号最大所以服务器 3 胜出，此时投票数正好大于半数，所以服务器 3 成为领导者，服务器 1,2 成为小弟。
		* 服务器 4 启动，给自己投票，同时与之前启动的服务器 1,2,3 交换信息，尽管服务器 4 的编号大，但之前服务器 3 已经胜出，所以服务器 4 只能成为小弟。
		* 服务器 5 启动，后面的逻辑同服务器 4 成为小弟。

		<img src="https://upload-images.jianshu.io/upload_images/22827736-0ad0797644bb0593.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" width="100%">

	
	* 非全新集群选举
		对于正常运行的ZK集群，中途有机器宕机，需要重新进行选举，选举过程中就需要加入数据ID、服务器ID、逻辑时钟
		
		**数据 ID：** 数据新的 version 就大，数据每次更新都会更新 version。  
		**服务器 ID：** 就是我们配置的 myid 中的值，每个机器一个。  
		**逻辑时钟：** 这个值从 0 开始递增,每次选举对应一个值。 如果在同一次选举中,这个值是一致的。
		
		这样选举的标准就变成：

		逻辑时钟小的选举结果被忽略，重新投票；
		统一逻辑时钟后，数据 id 大的胜出；
		数据 id 相同的情况下，服务器 id 大的胜出；

